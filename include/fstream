/*	Copyright (C) 2004 Garrett A. Kajmowicz

	This file is part of the uClibc++ Library.
	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License as published by the Free Software Foundation; either
	version 2.1 of the License, or (at your option) any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with this library; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include<basic_definitions>

#include <iosfwd>
#include <cstdio>
#include <cstdlib>
#include <ios>
#include <streambuf>
#include <istream>
#include <ostream>

#ifndef __STD_HEADER_FSTREAM 
#define __STD_HEADER_FSTREAM 1

namespace std{

	template <class charT, class traits> class basic_filebuf : public basic_streambuf<charT,traits> {
#ifdef __UCLIBCXX_SUPPORT_CDIR__
		friend ios_base::Init::Init();	//Needed for cout/cin stuff
#endif
	public:
		// Types (inherited from basic_streambuf:
		typedef typename basic_streambuf<charT, traits>::char_type	char_type;
		typedef typename basic_streambuf<charT, traits>::int_type 	int_type;
		typedef typename basic_streambuf<charT, traits>::pos_type	pos_type;
		typedef typename basic_streambuf<charT, traits>::off_type	off_type;
		typedef traits							traits_type;

		//Constructors/destructor:

		basic_filebuf() : basic_streambuf<charT,traits>(), fp(0), pbuffer(0), gbuffer(0) {
			pbuffer = new char_type[__UCLIBCXX_IOSTREAM_BUFSIZE__];
			gbuffer = new char_type[__UCLIBCXX_IOSTREAM_BUFSIZE__];

			setp(pbuffer, pbuffer + __UCLIBCXX_IOSTREAM_BUFSIZE__);
			//Position get buffer so that there is no data available
			setg(gbuffer, gbuffer + __UCLIBCXX_IOSTREAM_BUFSIZE__,
				gbuffer + __UCLIBCXX_IOSTREAM_BUFSIZE__);
		}

		virtual ~basic_filebuf();

		//Members:

		bool is_open() const{
			if(fp == 0){
				return false;
			}
			return true;
		}

		basic_filebuf<charT,traits>* open(const char* s, ios_base::openmode mode){
			bool move_end = (mode & ios_base::ate) != 0;
			if(is_open() !=false){	//Must call close() first
				return 0;
			}
			mode = mode & ~ios_base::ate;
			if(mode == ios_base::out || mode == (ios_base::out | ios_base::trunc)){
				fp = fopen(s, "w" );
			}else if(mode == (ios_base::out | ios_base::app)){
				fp = fopen(s, "a");
			}else if(mode == ios_base::in){
				fp = fopen(s, "r");
			}else if(mode == (ios_base::in | ios_base::out)){
				fp = fopen(s, "r+");
			}else if(mode == (ios_base::in | ios_base::out | ios_base::trunc)){
				fp = fopen(s, "w+");
			}else if(mode == (ios_base::binary | ios_base::out) 
				|| mode==(ios_base::binary | ios_base::out | ios_base::trunc))
			{
				fp = fopen(s, "wb");
			}else if(mode == (ios_base::binary | ios_base::out | ios_base::app)){
				fp = fopen(s, "ab");
			}else if(mode == (ios_base::in | ios_base::binary)){
				fp = fopen(s, "rb");
			}else if(mode == (ios_base::in | ios_base::binary | ios_base::out)){
				fp = fopen(s, "r+b");
			}else if(mode == (ios_base::in | ios_base::binary | ios_base::out | ios_base::trunc)){
				fp = fopen(s, "w+b");
			}

			if(fp == 0){
				return 0;
			}
			int retval = 0;
			if(move_end == true){
				retval = fseek(fp, 0, SEEK_END);
				if(retval!=0){		//Seek error
					fclose(fp);
					fp=0;
					return 0;
				}
			}
			return this;
		}
		basic_filebuf<charT,traits>* close(){
			if(fp != 0){
				overflow();
				int retval = fclose(fp);
				if(retval !=0){		//Error of some sort
					return 0;
				}
				fp=0;
			}
			return this;
		}
	protected:
		basic_filebuf(const basic_filebuf<charT,traits> &){ }
		basic_filebuf<charT,traits> & operator=(const basic_filebuf<charT,traits> &){ return *this; }

		//Overridden virtual functions:

		virtual int showmanyc(){
			return basic_streambuf<charT,traits>::egptr() - basic_streambuf<charT,traits>::gptr();
		}
		virtual int_type underflow(){
			/* Some variables used internally:
			   Buffer pointers:
			   charT * mgbeg;
			   charT * mgnext;
			   charT * mgend;

			   eback() returns mgbeg
			   gptr()  returns mgnext
			   egptr() returns mgend

			   gbump(int n) mgnext+=n

			*/

			if(basic_streambuf<charT,traits>::eback() == 0){
				//No buffer, so...
				charT c;
				int retval;
				retval = fscanf(fp, "%1c", &c);

				printf("Calling zero buffer underflow\n");

				if(retval == EOF){
					return traits::eof();
				}
				if(retval < 0){
					abort();
				}
				return c;
			}

			if(basic_streambuf<charT,traits>::eback() == basic_streambuf<charT,traits>::gptr()){	//Buffer is full
				return traits::to_int_type(*basic_streambuf<charT,traits>::gptr());
			}
			//Shift entire buffer back to the begining
			size_t offset = basic_streambuf<charT,traits>::gptr() - basic_streambuf<charT,traits>::eback();
			size_t amountData = basic_streambuf<charT,traits>::egptr() - basic_streambuf<charT,traits>::gptr();

			for(charT * i = basic_streambuf<charT,traits>::gptr(); i < basic_streambuf<charT,traits>::egptr(); ++i){
				*(i-offset) = *i;
			}

			//Fill rest of buffer
			size_t retval;
			retval = fread(basic_streambuf<charT,traits>::egptr() - 
				basic_streambuf<charT,traits>::gptr() + basic_streambuf<charT,traits>::eback(),
				sizeof(charT),
//				offset,
				1,
				fp
			);

			if(retval !=offset){ //Slide buffer forward again
				for(size_t i = 0; i < amountData + retval; ++i){
					*(basic_streambuf<charT,traits>::egptr() - i - 1) =
						*(basic_streambuf<charT,traits>::eback() + amountData + retval - i - 1);
				}
			}

			basic_streambuf<charT,traits>::mgnext -= retval;

			if(feof(fp)){
				return traits::eof();
			}
			if(ferror(fp)){
				printf("Error trying to run scanf\n");
				abort();
			}

			return traits::to_int_type(*basic_streambuf<charT,traits>::gptr());
		}
		virtual int_type uflow(){
			bool dobump = (basic_streambuf<charT,traits>::gptr() != basic_streambuf<charT,traits>::egptr());
			int_type retval = underflow();
			if(dobump){
				basic_streambuf<charT,traits>::gbump(1);
			}
			return retval;
		}
		virtual int_type pbackfail(int_type c = traits::eof()){
			if(is_open() == false || 
				basic_streambuf<charT,traits>::gptr() == basic_streambuf<charT,traits>::eback())
			{
				return traits::eof();
			}
			if(traits::eq_int_type(c,traits::eof()) == false){
				if(traits::eq(traits::to_char_type(c), basic_streambuf<charT,traits>::gptr()[-1]) == true){
					basic_streambuf<charT,traits>::gbump(-1);
				}else{
					basic_streambuf<charT,traits>::gbump(-1);
					basic_streambuf<charT,traits>::gptr()[0] = c;
				}
				return c;
			}else{
				basic_streambuf<charT,traits>::gbump(-1);
				return traits::not_eof(c);
			}
		}
		virtual int_type overflow (int_type c = traits::eof()){
			if(is_open() == false){
				//Can't do much
				return traits::eof();
			}
			if(basic_streambuf<charT,traits>::pbase() == 0){		//Unbuffered
				if(fputc(c, fp) == EOF){
					return traits::eof();
				}
				return c;
			}
			if(basic_streambuf<charT,traits>::pbase() == 0 && traits::eq_int_type(c,traits::eof()) ){
				//Nothing to flush
				return traits::not_eof(c);
			}
			size_t r = basic_streambuf<charT,traits>::pptr() - basic_streambuf<charT,traits>::pbase();

			if( r == 0 && traits::eq_int_type(c,traits::eof()) ){
				return traits::not_eof(c);
			}else if (r == 0 ){
				if(fputc(c, fp) == EOF){
					return traits::eof();
				}
				return c;
			}

			size_t s = r;

			char_type *buffer = 0;
			if(traits::eq_int_type(c,traits::eof())){
				buffer = new char_type[r];
			}else{
				buffer = new char_type[r+1];
				buffer[r] = c;
				s++;
			}
			if(r!=0){	//Nothing to do
				traits::copy(buffer, basic_streambuf<charT,traits>::pbase(), r);
			}

			size_t retval = fwrite(buffer, sizeof(charT), s, fp);
			if(retval !=s){
				if(retval == 0){
					delete [] buffer;
					return traits::eof();
				}
				basic_streambuf<charT,traits>::pbump(-retval);
			}else{
				basic_streambuf<charT,traits>::pbump(-r);
			}

			delete [] buffer;
			return traits::not_eof(c);
		}
		virtual basic_streambuf<charT,traits>* setbuf(char_type* s, streamsize n){
			if(s == 0 && n == 0){	//Unbuffered
				if(pbuffer !=0){
					delete [] pbuffer;
				}
				if(gbuffer !=0){
					delete [] gbuffer;
				}
				pbuffer = 0;
				gbuffer = 0;
			}else if(basic_streambuf<charT,traits>::gptr() !=0 && 
				basic_streambuf<charT,traits>::gptr()==basic_streambuf<charT,traits>::egptr())
			{
				delete [] pbuffer;
				pbuffer = s;
			}
			return this;
		}
		virtual pos_type seekoff(off_type off, ios_base::seekdir way, 
			ios_base::openmode = ios_base::in | ios_base::out)
		{
			if(is_open() == false){
				return -1;
			}
			int whence = SEEK_SET;	// if(way == basic_ios<charT>::beg)

			if(way == basic_ios<charT>::cur){
				whence = SEEK_CUR;
			}else if(way == basic_ios<charT>::end){
				whence = SEEK_END;
			}

			sync();

			int retval = fseek(fp,sizeof(charT)*(off - (basic_streambuf<charT,traits>::egptr() - basic_streambuf<charT,traits>::gptr())),whence);

			//Invalidate read buffer
			basic_streambuf<charT,traits>::gbump(basic_streambuf<charT,traits>::egptr() - basic_streambuf<charT,traits>::gptr());

			return retval;
		}
		virtual pos_type seekpos(pos_type sp, ios_base::openmode = ios_base::in | ios_base::out){
			if(is_open() == false){
				return -1;
			}
			sync();

			int retval = fseek(fp,sizeof(charT)* sp, SEEK_SET);

			//Invalidate read buffer
			basic_streambuf<charT,traits>::gbump(basic_streambuf<charT,traits>::egptr() - basic_streambuf<charT,traits>::gptr());
			if(retval > -1){
				return sp;
			}
			return -1;
		}
		virtual int sync(){
			if(pbuffer !=0){
				if(overflow() == traits::eof()){
					return -1;
				}
			}
			return 0;
		}
		virtual void imbue(const locale&){
			return;
		}


		virtual streamsize xsputn(const char_type* s, streamsize n){
			if(is_open() == false){
				return 0;
			}
			//Check to see if buffered

			//Check to see if we can buffer the data
			streamsize buffer_avail = basic_streambuf<charT,traits>::epptr() - basic_streambuf<charT,traits>::pptr();

			streamsize len = traits::length(s);
			if(len > n){
				len = n;
			}

			if(len > buffer_avail){		//Flush buffer and write directly
				overflow();	//Flush the buffer
				char buffer[30];
				snprintf(buffer, 29, "%%.%ds", static_cast<unsigned int>(len) );
				return fprintf(fp, buffer, s);
			}

			//Add to buffer to be written later

			traits::copy(basic_streambuf<charT,traits>::pptr(), s, len);
			basic_streambuf<charT,traits>::pbump(len);

			return len;
		}

		FILE * fp;
		char_type * pbuffer;
		char_type * gbuffer;
	};

	template <class charT, class traits> basic_filebuf<charT, traits>::~basic_filebuf()
	{
		close();
		delete [] pbuffer;
		delete [] gbuffer;
		pbuffer = 0;
		gbuffer = 0;
	}



#ifdef __UCLIBCXX_EXPAND_FSTREAM_CHAR__
#ifndef __UCLIBCXX_COMPILE_FSTREAM__

	template <> basic_filebuf<char, char_traits<char> >::~basic_filebuf();

	template <> basic_filebuf<char, char_traits<char> >::int_type basic_filebuf<char, char_traits<char> >::
		pbackfail(basic_filebuf<char, char_traits<char> >::int_type c);

	template <> basic_filebuf<char, char_traits<char> > * basic_filebuf<char, char_traits<char> >::
		open(const char* s, ios_base::openmode mode);

	template <> basic_filebuf<char, char_traits<char> >::int_type basic_filebuf<char, char_traits<char> >::
		overflow (basic_filebuf<char, char_traits<char> >::int_type c);

	template <> basic_filebuf<char, char_traits<char> >::int_type
		basic_filebuf<char, char_traits<char> >::underflow ();

	template <> basic_streambuf<char, char_traits<char> >*
		basic_filebuf<char, char_traits<char> >::
		setbuf(char * s, streamsize n);

	template <> streamsize basic_filebuf<char, char_traits<char> >::xsputn(const char* s, streamsize n);

#endif
#endif


	typedef basic_filebuf<char>    filebuf;
#ifdef __UCLIBCXX_HAS_WCHAR__
	typedef basic_filebuf<wchar_t> wfilebuf;
#endif



	template <class charT, class traits>
		class basic_ifstream : public basic_istream<charT,traits>
	{
	public:
		typedef charT char_type;
		typedef typename traits::int_type int_type;
		typedef typename traits::pos_type pos_type;
		typedef typename traits::off_type off_type;

		basic_ifstream(): basic_istream<charT,traits>(&sb){
			//Passing the address of sb
		}
		explicit basic_ifstream(const char* s, ios_base::openmode mode = ios_base::in) : basic_istream<charT,traits>(&sb){
			if(sb.open(s, mode) == 0){
				basic_ios<charT,traits>::setstate(ios_base::failbit);
			}
		}
		basic_filebuf<charT,traits>* rdbuf() const{
			return &sb;
		}
		bool is_open(){
			return sb.is_open();
		}
		void open(const char* s, ios_base::openmode mode = ios_base::in){
			sb.open(s, mode);
		}
		void close(){
			sb.close();
		}
	private:
		basic_filebuf<charT,traits> sb;
	};


	template <class charT, class traits> class basic_ofstream : public basic_ostream<charT,traits> {
	public:
		typedef charT char_type;
		typedef typename traits::int_type int_type;
		typedef typename traits::pos_type pos_type;
		typedef typename traits::off_type off_type;

		basic_ofstream() : basic_ostream<charT,traits>(&sb){

		}

		virtual ~basic_ofstream();

		explicit basic_ofstream(const char* s, ios_base::openmode mode = ios_base::out | ios_base::trunc) :
			basic_ostream<charT,traits>(&sb)
		{
			if(sb.open(s, mode) == 0){
				basic_ios<charT,traits>::setstate(ios_base::failbit);
			}
		}

		basic_filebuf<charT,traits>* rdbuf() const{
			return &sb;
		}

		bool is_open(){
			return sb.is_open();
		}
		void open(const char* s, ios_base::openmode mode = ios_base::out | ios_base::trunc){
			sb.open(s, mode);
		}
		void close(){
			sb.close();
		}
	private:
		basic_filebuf<charT,traits> sb;
	};

	template <class charT, class traits> basic_ofstream<charT, traits>::~basic_ofstream(){
	
	}


#ifdef __UCLIBCXX_EXPAND_FSTREAM_CHAR__
#ifndef __UCLIBCXX_COMPILE_FSTREAM__

	template <> basic_ofstream<char, char_traits<char> >::~basic_ofstream();


#endif
#endif



	template <class charT, class traits> class basic_fstream : public basic_iostream<charT,traits> {
	public:
		typedef charT char_type;
		typedef typename traits::int_type ins_type;
		typedef typename traits::pos_type pos_type;
		typedef typename traits::off_type off_type;

		basic_fstream(): basic_iostream<charT,traits>(&sb){ }
		explicit basic_fstream(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out):
			basic_iostream<charT,traits>(&sb)
		{
			sb.open(s, mode);
		}

		basic_filebuf<charT,traits>* rdbuf() const{
			return &sb;
		}
		bool is_open(){
			return sb.is_open();
		}
		void open(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out){
			sb.open(s, mode);
		}
		void close(){
			sb.close();
		}
	private:
		basic_filebuf<charT,traits> sb;
	};

}

#endif

