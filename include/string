/*	Copyright (C) 2004 Garrett A. Kajmowicz

	This file is part of the uClibc++ Library.

	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License as published by the Free Software Foundation; either
	version 2.1 of the License, or (at your option) any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with this library; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include <basic_definitions>
#include <char_traits>
#include <string.h>
#include <exception>
#include <func_exception>
#include <memory>
#include <vector>
//#include <iostream>


#ifdef __USE_WCHAR
#include <wchar.h>
#include <wctype.h>
#endif

#ifndef __HEADER_STD_STRING
#define __HEADER_STD_STRING 1

namespace std{

	//Basic basic_string

template<class Ch, class Tr = char_traits<Ch>, class A = allocator<Ch> > class basic_string
	: public std::vector<Ch, A>
{
public:
	typedef Tr traits_type;
	typedef typename Tr::char_type value_type;
	typedef A allocator_type;
	typedef typename A::size_type size_type;
	typedef typename A::difference_type difference_type;

	typedef typename A::reference reference;
	typedef typename A::const_reference const_reference;
	typedef typename A::pointer pointer;
	typedef typename A::const_pointer const_pointer;

	typedef typename vector<Ch, A>::iterator iterator;
	typedef typename vector<Ch, A>::const_iterator const_iterator;
	typedef char * iterator;
	typedef char * const_iterator;

	typedef typename vector<Ch, A>::reverse_iterator iterator;
	typedef typename vector<Ch, A>::const_reverse_iterator const_iterator;

	static const size_type npos = -1;

	explicit basic_string(const A& al = A()) : vector<Ch, A>(al){ return; }

	basic_string(const basic_string& str, size_type pos = 0, size_type n = npos, const A& al = A()) 
		: vector<Ch, A>(al)
	{
		if(pos>str.size()){
			__throw_out_of_range();
		}
		size_type rlen = str.size() - pos;
		if( rlen > n){
			rlen = n;
		}
		reserve(rlen);

		vector<Ch, A>::elements = rlen;
		Tr::copy(vector<Ch, A>::data, str.vector<Ch, A>::data + pos, vector<Ch, A>::elements);
	}

	basic_string(const Ch* s, size_type n, const A& al = A())
		: vector<Ch, A>(al)
	{
		if(n == npos){
			__throw_out_of_range();
		}
		if(s > 0){
			reserve(n);
			vector<Ch, A>::elements = n;
			Tr::copy(vector<Ch, A>::data, s, vector<Ch, A>::elements);
		}
	}

	basic_string(const Ch* s, const A& al = A());
	
	basic_string(size_type n, Ch c, const A& al = A())
		: vector<Ch, A>(n, c, al)
	{
	}

	template<class InputIterator> basic_string(InputIterator begin, InputIterator end, const A& a = A())
		:vector<Ch, A>(begin, end)
	{
		
	}
	~basic_string() { }

	basic_string& operator=(const basic_string& str){
		if(&str == this){	//Check if we are doing a=a 
			return *this;
		}
		vector<Ch, A>::clear();
		reserve(str.elements);
		Tr::copy( vector<Ch, A>::data, str.vector<Ch, A>::data, str.elements);
		vector<Ch, A>::elements = str.elements;
		return *this;
	}

	basic_string& operator=(const Ch* s){
		vector<Ch, A>::clear();
		if(s!=0){
			size_type len = Tr::length(s);
			reserve(len);
			Tr::copy( vector<Ch, A>::data, s, len);
			vector<Ch, A>::elements = len;
		}
		return *this;
	}

	basic_string& operator=(Ch c){
		vector<Ch, A>::clear();
		push_back(c);
		return *this;
	}

	inline size_type length() const { return vector<Ch, A>::size(); }

	void resize(size_type n){
		vector<Ch, A>::resize(n, Ch() );
	}

	basic_string& operator+=(const basic_string& str){
		return append(str);
	}

	basic_string& operator+=(const Ch * s){
		return append(s);;
	}

	basic_string& operator+=(Ch c){
		push_back(c);
		return *this;
	}

	basic_string& append(const basic_string& str){
		reserve(vector<Ch, A>::elements + str.elements);
		Tr::copy( vector<Ch, A>::data + vector<Ch, A>::elements, str.vector<Ch, A>::data, str.elements);
		vector<Ch, A>::elements += str.elements;

		return *this;
	}

	basic_string& append(const basic_string& str, size_type pos, size_type n){
		if(pos > str.size()){
			__throw_out_of_range();
		}

		size_type rlen = str.elements - pos;
		if(rlen > n){
			rlen = n;
		}
		if(vector<Ch, A>::elements > npos - rlen){
			__throw_length_error();
		}
		reserve(vector<Ch, A>::elements + rlen);
		vector<Ch, A>::elements += rlen;
		Tr::copy( vector<Ch, A>::data + vector<Ch, A>::elements, str.vector<Ch, A>::data, rlen);
		return *this;
	}
		
	basic_string& append(const Ch* s, size_type n){
		reserve(vector<Ch, A>::elements + n);
		Tr::copy( vector<Ch, A>::data + vector<Ch, A>::elements, s, n);
		vector<Ch, A>::elements+=n;
		return *this;
	}
	basic_string& append(const Ch* s){
		size_type strLen = Tr::length(s);
		reserve(vector<Ch, A>::elements + strLen);
		Tr::copy( vector<Ch, A>::data + vector<Ch, A>::elements, s, strLen);
		vector<Ch, A>::elements+=strLen;
		return *this;
	}

	basic_string& append(size_type n, Ch c){
		vector<Ch, A>::resize(vector<Ch, A>::elements+ n, c);
		return *this;
	}

	basic_string& assign(const basic_string& str){
		*this = str;
		return *this;
	}

	basic_string& assign(const basic_string& str, size_type pos, size_type n){
		if(pos > str.elements){
			__throw_out_of_range();
		}
		size_type r = str.elements - pos;
		if(r > n){
			r = n;
		}
		if(vector<Ch, A>::data_size < r){
			//Not using reserve() because we don't need to keep the old data
			vector<Ch, A>::a.deallocate(vector<Ch, A>::data, vector<Ch, A>::data_size);
			vector<Ch, A>::data_size = r + __UCLIBCXX_STL_BUFFER_SIZE__;
			vector<Ch, A>::data = vector<Ch, A>::a.allocate(vector<Ch, A>::data_size);
		}
		Tr::copy(vector<Ch, A>::data, str.vector<Ch, A>::data + pos, r);
		vector<Ch, A>::elements = r;
		return *this;
	}

	basic_string& assign(const Ch* s, size_type n){
		if( n > vector<Ch, A>::data_size ){
			vector<Ch, A>::a.deallocate(vector<Ch, A>::data, vector<Ch, A>::data_size);
			vector<Ch, A>::data = vector<Ch, A>::a.allocate(vector<Ch, A>::data_size);
		}
		vector<Ch, A>::elements = n;
		Tr::copy(vector<Ch, A>::data, s, n);
		return *this;
	}

	basic_string& assign(const Ch* s){
		size_type len = Tr::length(s);
		return assign(s, len);
	}

	basic_string& assign(size_type n, Ch c){
		if(n > vector<Ch, A>::data_size){
			vector<Ch, A>::a.deallocate(vector<Ch, A>::data, vector<Ch, A>::data_size);
			vector<Ch, A>::data_size = n + __UCLIBCXX_STL_BUFFER_SIZE__;
			vector<Ch, A>::data = vector<Ch, A>::a.allocate(vector<Ch, A>::data_size);
		}
		Tr::assign( vector<Ch, A>::data, n ,c);
		vector<Ch, A>::elements = n;
		return *this;
	}

//	template<class InputIterator> basic_string& assign(InputIterator first, InputIterator last);

	basic_string& insert(size_type pos1, const basic_string& str){
		if(pos1 > vector<Ch, A>::elements){
			__throw_out_of_range();
		}
		if(vector<Ch, A>::elements > npos - str.elements){
			__throw_length_error();
		}
		reserve(str.elements + vector<Ch, A>::elements);

		Tr::move(vector<Ch, A>::data + pos1 + str.elements, vector<Ch, A>::data + pos1, str.elements);
		Tr::copy(vector<Ch, A>::data + pos1, str.vector<Ch, A>::data, str.elements);
		vector<Ch, A>::elements += str.elements;
		return *this;
	}

	basic_string& insert(size_type pos1, const basic_string& str, size_type pos2=0, size_type n=npos){
		if(pos1 > vector<Ch, A>::elements || pos2 > str.elements){
			__throw_out_of_range();
		}
		size_type r = str.elements - pos2;
		if( r > n){
			r = n;
		}
		if(vector<Ch, A>::elements > npos - r){
			__throw_length_error();
		}
		reserve(vector<Ch, A>::elements + r);
		Tr::move(vector<Ch, A>::data + pos1 + r, vector<Ch, A>::data + pos1, r);
		Tr::copy(vector<Ch, A>::data + pos1, str.vector<Ch, A>::data + pos2, r);
		vector<Ch, A>::elements+=r;
		return *this;
	}

	basic_string& insert(size_type pos, const Ch* s, size_type n){
		if(pos > vector<Ch, A>::elements){
			__throw_out_of_range();
		}
		if(vector<Ch, A>::elements > pos - n){
			__throw_length_error();
		}
		reserve(vector<Ch, A>::elements + n);
		Tr::move(vector<Ch, A>::data + pos + n, vector<Ch, A>::data + pos, n);
		Tr::copy(vector<Ch, A>::data + pos, s, n);
		vector<Ch, A>::elements+=n;
		return *this;
	}

	inline basic_string& insert(size_type pos, const Ch* s){
		size_type len = Tr::length(s);
		return insert(pos, s, len);
	}

	basic_string& insert(size_type pos, size_type n, Ch c){
		if(pos > vector<Ch, A>::elements){
			__throw_out_of_range();
		}
		if(vector<Ch, A>::elements > pos - n){
			__throw_length_error();
		}
		reserve(vector<Ch, A>::elements + n);
		Tr::move(vector<Ch, A>::data + pos + n, vector<Ch, A>::data + pos, n);
		Tr::assign(vector<Ch, A>::data + pos, n, c);
		vector<Ch, A>::elements+=n;
		return *this;
	}

//	iterator insert(iterator p, charT c = charT());
//	void insert(iterator p, size_type n, charT c);
//	template<class InputIterator> void insert(iterator p, InputIterator first, InputIterator last);

	basic_string& erase(size_type pos = 0, size_type n = npos){
		size_type xlen = vector<Ch, A>::elements - pos;
		if(xlen > n){
			xlen = n;
		}
		if( (vector<Ch, A>::elements - pos) > n){		//Deleteing past the end
			resize(pos);
		}else{				//Deleting from the middle
			Tr::move(vector<Ch, A>::data + pos, vector<Ch, A>::data + pos + xlen, xlen);
			resize(pos + xlen);
		}
		return *this;
	}

	iterator erase(iterator position){
		if(position == vector<Ch, A>::end()){
			return position;
		}

		++position;

		iterator temp = position;

		while(position != vector<Ch, A>::end()){
			*(position-1) = *position;
			++position;
		}
		--vector<Ch, A>::elements;
		return temp;
	}

	iterator erase(iterator first, iterator last){
		size_t count = last - first;

		iterator temp = last;

		while(last != vector<Ch, A>::end()){
			*(last - count) = *last;
			++last;
		}

		vector<Ch, A>::elements-= count;

		return temp;
	}

//	basic_string& replace(size_type pos1, size_type n1, const basic_string& str);

	basic_string& replace(size_type pos1, size_type n1, const basic_string& str, size_type pos2=0, size_type n2=npos){
		if(pos1 > vector<Ch, A>::elements){
			__throw_out_of_range();
		}
		size_type xlen = vector<Ch, A>::elements - pos1;
		if(xlen >  n1){
			xlen = n1;
		}
		size_type rlen = str.elements - pos2;
		if(rlen > n2){
			rlen = n2;
		}
		if((vector<Ch, A>::elements - xlen) >= (npos - rlen)){
			__throw_length_error();
		}
		reserve(vector<Ch, A>::elements - xlen + rlen);

		//Final length = vector<Ch, A>::elements - xlen + rlen
		//Initial block is of size pos1
		//Block 2 is of size len

		Tr::move(vector<Ch, A>::data + pos1 + rlen, vector<Ch, A>::data + pos1 + xlen, vector<Ch, A>::elements - pos1 - xlen);
		Tr::copy(vector<Ch, A>::data + pos1, str.vector<Ch, A>::data + pos2, rlen);
		vector<Ch, A>::elements = vector<Ch, A>::elements - xlen + rlen;
		return *this;
	}

	basic_string& replace(size_type pos, size_type n1, const Ch* s, size_type n2){
		return replace(pos,n1,basic_string<Ch,Tr,A>(s,n2));
		
	}

	inline basic_string& replace(size_type pos, size_type n1, const Ch* s){
		return replace(pos,n1,basic_string<Ch,Tr,A>(s));
	}

	basic_string& replace(size_type pos, size_type n1, size_type n2, Ch c){
		return replace(pos,n1,basic_string<Ch, Tr, A>(n2,c));
	}
//	basic_string& replace(iterator i1, iterator i2, const basic_string& str);
//	basic_string& replace(iterator i1, iterator i2, const Ch* s, size_type n);
//	basic_string& replace(iterator i1, iterator i2, const Ch* s);
//	basic_string& replace(iterator i1, iterator i2, size_type n, Ch c);
/*	template<class InputIterator> basic_string& replace(iterator i1, iterator i2,
		InputIterator j1, InputIterator j2);*/

	size_type copy(Ch* s, size_type n, size_type pos = 0) const{
		if(pos > vector<Ch, A>::elements){
			__throw_out_of_range();
		}
		size_type r = vector<Ch, A>::elements - pos;
		if(r > n){
			r = n;
		}
		Tr::copy(s, vector<Ch, A>::data + pos, r);
		return r;
	}

	void swap(basic_string<Ch,Tr,A>& s){
		//Data pointers

		vector<Ch, A>::swap(s);
	}

	const Ch* c_str() const{
		const_cast<basic_string<Ch,Tr,A> *>(this)->reserve(vector<Ch, A>::elements+1);
		vector<Ch, A>::data[vector<Ch, A>::elements] = 0;	//Add 0 at the end
		return vector<Ch, A>::data;
	}

	const Ch* data() const{
		return vector<Ch, A>::data;
	}
	allocator_type get_allocator() const{
		return vector<Ch, A>::a;
	}

	size_type find (const basic_string& str, size_type pos = 0) const{
		if(str.length() > length()){
			return npos;
		}
		size_type max_string_start = length() - str.length();
		for(size_type i = pos; i < max_string_start; ++i){
			if(str == substr(i, str.length())){
				return i;
			}
		}

		return npos;
	}
	size_type find (const Ch* s, size_type pos, size_type n) const{
		return find(basic_string<Ch, Tr, A>(s,n),pos);
	}
	size_type find (const Ch* s, size_type pos = 0) const{
		return find(basic_string<Ch, Tr, A>(s),pos);
	}
	size_type find (Ch c, size_type pos = 0) const{
		return find(basic_string<Ch, Tr, A>(1,c),pos);
	}
	size_type rfind(const basic_string& str, size_type pos = npos) const{
		if(pos >= length()){
			pos = length();
		}
		for(size_type i = pos; i > 0; --i){
			if(str == substr(i-1, str.length())){
				return i-1;
			}
		}
		return npos;
	}
	size_type rfind(const Ch* s, size_type pos, size_type n) const{
		return rfind(basic_string<Ch, Tr, A>(s,n),pos);
	}
	size_type rfind(const Ch* s, size_type pos = npos) const{
		return rfind(basic_string<Ch, Tr, A>(s),pos);
	}
	size_type rfind(Ch c, size_type pos = npos) const{
		return rfind(basic_string<Ch, Tr, A>(1,c),pos);
	}
/*	size_type find_first_of(const basic_string& str, size_type pos = 0) const;
	size_type find_first_of(const charT* s, size_type pos, size_type n) const;
	size_type find_first_of(const charT* s, size_type pos = 0) const;
	size_type find_first_of(charT c, size_type pos = 0) const;
	size_type find_last_of (const basic_string& str, size_type pos = npos) const;
	size_type find_last_of (const charT* s, size_type pos, size_type n) const;
	size_type find_last_of (const charT* s, size_type pos = npos) const;
	size_type find_last_of (charT c, size_type pos = npos) const;

	size_type find_first_not_of(const basic_string& str, size_type pos = 0) const;
	size_type find_first_not_of(const charT* s, size_type pos, size_type n) const;
	size_type find_first_not_of(const charT* s, size_type pos = 0) const;
	size_type find_first_not_of(charT c, size_type pos = 0) const;
	size_type find_last_not_of (const basic_string& str, size_type pos = npos) const;
	size_type find_last_not_of (const charT* s, size_type pos, size_type n) const;
	size_type find_last_not_of (const charT* s, size_type pos = npos) const;
	size_type find_last_not_of (charT c, size_type pos = npos) const;
*/

	basic_string substr(size_type pos = 0, size_type n = npos) const{
		if(pos > vector<Ch, A>::elements){
			__throw_out_of_range();
		}
		size_type rlen = vector<Ch, A>::elements - pos;
		if(rlen > n){
			rlen = n;
		}
		return basic_string<Ch,Tr,A>(vector<Ch, A>::data + pos,rlen);
	}

	int compare(const basic_string& str) const{
		size_type rlen = vector<Ch, A>::elements;
		if(rlen >  str.elements){
			rlen = str.elements;
		}
		int retval = Tr::compare(vector<Ch, A>::data, str.vector<Ch, A>::data, rlen);
		if(retval == 0){
			if(vector<Ch, A>::elements < str.elements){
				retval = -1;
			}
			if(vector<Ch, A>::elements > str.elements){
				retval = 1;
			}
		}
		return retval;
	}

	int compare(size_type pos1, size_type n1, const basic_string& str) const{
		size_type rlen = vector<Ch, A>::elements - pos1;
		if(rlen > n1){
			rlen = n1;
		}
		if(rlen > str.elements){
			rlen = str.elements;
		}
		int retval = Tr::compare(vector<Ch, A>::data + pos1, str.vector<Ch, A>::data, rlen);
		if(retval == 0){
			if(vector<Ch, A>::elements - pos1 < str.elements){
				retval = -1;
			}
			if(vector<Ch, A>::elements - pos1 > str.elements){
				retval = 1;
			}
		}
		return retval;
	}

	int compare(size_type pos1, size_type n1, const basic_string& str,
		size_type pos2=0, size_type n2=npos) const{
		size_type len1 = vector<Ch, A>::elements - pos1;
		if(len1 > n1){
			len1 = n1;
		}
		size_type len2 = vector<Ch, A>::elements - pos2;
		if(len2 > n2){
			len2 = n2;
		}
		size_type rlen = len1;
		if(rlen > len2){
			rlen = len2;
		}
		int retval = Tr::compare(vector<Ch, A>::data + pos1, str.vector<Ch, A>::data + pos2, rlen);
		if(retval == 0){
			if(len1 < len2){
				retval = -1;
			}
			if(len1 > len2){
				retval = 1;
			}
		}
		return retval;
	}

	int compare(const Ch* s) const{
		size_type slen = Tr::length(s);
		size_type rlen = slen;
		if(rlen > vector<Ch, A>::elements){
			rlen=vector<Ch, A>::elements;
		}
		int retval = Tr::compare(vector<Ch, A>::data, s, rlen);
		if(retval==0){
			if(vector<Ch, A>::elements < slen){
				retval = -1;
			}
			if(vector<Ch, A>::elements > slen){
				retval = 1;
			}
		}
		return retval;
	}

	int compare(size_type pos1, size_type n1, const Ch* s, size_type n2 = npos) const{
		size_type len1 = vector<Ch, A>::elements - pos1;
		if(len1 > n1){
			len1 = n1;
		}
		size_type slen = Tr::length(s);
		size_type len2 = slen;
		if(len2 > n2){
			len2 = n2;
		}
		size_type rlen = len1;
		if(rlen > len2){
			rlen = len2;
		}
		int retval  = Tr::compare(vector<Ch, A>::data + pos1, s, rlen);
		if(retval == 0){
			if(len1 < len2){
				retval = -1;
			}
			if(len1 > len2){
				retval = 1;
			}
		}
		return retval;
	}

};


//Functions

template<class Ch,class Tr,class A> basic_string<Ch,Tr,A>::basic_string(const Ch* s, const A& al)
	: vector<Ch, A>(al)
{
	if(s!=0){
		size_type temp = Tr::length(s);
		reserve(temp);
		for(size_type i = 0; i< temp; ++i){
			push_back(s[i]);
		}
	}
}

#ifdef __UCLIBCXX_EXPAND_STRING_CHAR__
#ifndef __UCLIBCXX_COMPILE_STRING__
	template<> basic_string<char,char_traits<char>, allocator<char> >::basic_string(const char* s, const allocator<char>& al);
#endif
#endif




//typedef basic_string<char> string;

template<class charT, class traits, class Allocator> basic_string<charT,traits,Allocator> 
	operator+(const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	basic_string<charT,traits,Allocator> temp(lhs);
	temp.append(rhs);
	return temp;
}

template<class charT, class traits, class Allocator> basic_string<charT,traits,Allocator>
	operator+(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	basic_string<charT,traits,Allocator> temp(lhs);
	temp.append(rhs);
	return temp;
}


template<class charT, class traits, class Allocator> basic_string<charT,traits,Allocator>
	operator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator> basic_string<charT,traits,Allocator>
	operator+(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	basic_string<charT,traits,Allocator> temp(lhs);
	temp.append(rhs);
	return temp;
}

template<class charT, class traits, class Allocator> basic_string<charT,traits,Allocator>
	operator+(const basic_string<charT,traits,Allocator>& lhs, charT rhs);

template<class charT, class traits, class Allocator> bool 
	operator==(const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	if(lhs.compare(rhs) == 0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator==(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	if(rhs.compare(lhs) == 0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	if(lhs.compare(rhs)==0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator!=(const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	if(lhs.compare(rhs) !=0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator!=(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	basic_string<charT,traits,Allocator> temp(lhs);
	return (temp != rhs);
}

template<class charT, class traits, class Allocator> bool 
	operator!=(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	basic_string<charT,traits,Allocator> temp(rhs);
	return (lhs != rhs);
}

template<class charT, class traits, class Allocator> bool 
	operator< (const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	if(lhs.compare(rhs) < 0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator< (const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	basic_string<charT,traits,Allocator> temp(rhs);
	if(lhs.compare(rhs) < 0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator< (const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	basic_string<charT,traits,Allocator> temp(lhs);
	if(temp.compare(rhs) < 0){
		return true;
	}
	return false;
}


template<class charT, class traits, class Allocator> bool 
	operator> (const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	if(lhs.compare(rhs) > 0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator> (const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	basic_string<charT,traits,Allocator> temp(rhs);
	if(lhs.compare(rhs) > 0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator> (const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	basic_string<charT,traits,Allocator> temp(lhs);
	if(temp.compare(rhs) > 0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator<=(const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	if(lhs.compare(rhs) <=0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator<=(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	basic_string<charT,traits,Allocator> temp(rhs);
	if(lhs.compare(temp <=0)){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator<=(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	basic_string<charT,traits,Allocator> temp(lhs);
	if(temp.compare(rhs) <0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator>=(const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	if(lhs.compare(rhs) >=0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator>=(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	basic_string<charT,traits,Allocator> temp(rhs);
	if(lhs.compare(temp)>=0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator>=(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	basic_string<charT,traits,Allocator> temp(lhs);
	if(temp.compare(rhs)>=0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> void 
	swap(basic_string<charT,traits,Allocator>& lhs, basic_string<charT,traits,Allocator>& rhs);

/*template<class charT, class traits, class Allocator> basic_ostream<charT, traits>&
	operator<<(basic_ostream<charT, traits>& os, const basic_string<charT,traits,Allocator>& str)
{
	return os.write(str.data(), str.length());
}*/

#ifdef __UCLIBCXX_EXPAND_STRING_CHAR__
#ifndef __UCLIBCXX_COMPILE_STRING__

//Operators we can avoid duplication of

template<> basic_string<char, char_traits<char>, allocator<char> >
	operator+(const basic_string<char, char_traits<char> , allocator<char> >& lhs, const char* rhs);

template<> basic_string<char, char_traits<char>, allocator<char> >
        operator+(const char* lhs, const basic_string<char, char_traits<char>, allocator<char> >& rhs);

//#ifdef __UCLIBCXX_EXPAND_OSTREAM_CHAR__
//template<> basic_ostream<char, char_traits<char> >&
//	operator<<(basic_ostream<char, char_traits<char> >& os, 
//	const basic_string<char,char_traits<char>, std::allocator<char> >& str);
//#endif
#endif
#endif

/*template<class charT, class traits, class Allocator> basic_istream<charT,traits>&
	operator>>(basic_istream<charT,traits>& is, basic_string<charT,traits,Allocator>& str)
{

	typename basic_istream<charT, traits>::sentry s(is);
	if(s == false){
		return is;
	}

	str.clear();

	typename basic_istream<charT, traits>::int_type c;
	typename Allocator::size_type n = is.width();
	bool exitnow = false;
	if(n == 0){
		n = str.max_size();
	}
	do{
		c = is.get();
		if(c == traits::eof() || isspace(c) || n == 0){
			exitnow = true;
		}else{
			str.append(1, traits::to_char_type(c) );
			--n;
		}
	}while(exitnow == false);
	return is;
}

template<class charT, class traits, class Allocator> basic_istream<charT,traits>&
	getline(basic_istream<charT,traits>& is, basic_string<charT,traits,Allocator>& str, charT delim)
{
	typename basic_istream<charT,traits>::sentry s;
	streamsize i = 0;
	typename basic_istream<charT,traits>::int_type c_i;
	charT c;
	unsigned int n = str.max_size();
	for(i=0;i<n;++i){
		c_i=is.get();
		if(c_i == traits::eof() ){
			return is;
		}
		c = traits::to_char_type(c_i);
		if(c == delim){
			return is;
		}
		str.append(c);
	}
	return is;	
}

template<class charT, class traits, class Allocator> basic_istream<charT,traits>&
	getline(basic_istream<charT,traits>& is, basic_string<charT,traits,Allocator>& str)
{
	return getline(is, str, '\n');
}

#ifdef __UCLIBCXX_EXPAND_ISTREAM_CHAR__
#ifdef __UCLIBCXX_EXPAND_STRING_CHAR__
#ifndef __UCLIBCXX_COMPILE_STRING__
template<> basic_istream<char, char_traits<char> >& operator>>(
	basic_istream<char,char_traits<char> >& is,
	basic_string<char, char_traits<char>, allocator<char> >& str);
#endif
#endif
#endif
*/

typedef basic_string<char> string;
typedef basic_string<wchar_t> wstring;


}

#endif

//#include <string_iostream>
