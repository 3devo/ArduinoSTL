/*	Copyright (C) 2004 Garrett A. Kajmowicz

	This file is part of the uClibc++ Library.

	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License as published by the Free Software Foundation; either
	version 2.1 of the License, or (at your option) any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with this library; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include <basic_definitions>
#include <char_traits>
#include <string.h>
#include <exception>
#include <func_exception>
#include <memory>
#include <vector>
#include <string_helpers>
#include <iostream>


#ifdef __USE_WCHAR
#include <wchar.h>
#include <wctype.h>
#endif

#ifndef __HEADER_STD_STRING
#define __HEADER_STD_STRING 1


namespace std{

	//Basic basic_string

template<class Ch, class Tr = char_traits<Ch>, class A = allocator<Ch> > class basic_string
	: public std::vector<Ch, A>
{
	friend class __string_helper_functions<Ch, Tr, A>;
public:
	typedef Tr traits_type;
	typedef typename Tr::char_type value_type;
	typedef A allocator_type;
	typedef typename A::size_type size_type;
	typedef typename A::difference_type difference_type;

	typedef typename A::reference reference;
	typedef typename A::const_reference const_reference;
	typedef typename A::pointer pointer;
	typedef typename A::const_pointer const_pointer;

	typedef typename vector<Ch, A>::iterator iterator;
	typedef typename vector<Ch, A>::const_iterator const_iterator;
	typedef char * iterator;
	typedef char * const_iterator;

	typedef typename vector<Ch, A>::reverse_iterator iterator;
	typedef typename vector<Ch, A>::const_reverse_iterator const_iterator;

	static const size_type npos = -1;

	explicit basic_string(const A& al = A()) : vector<Ch, A>(al){ return; }

	basic_string(const basic_string& str, size_type pos = 0, size_type n = npos, const A& al = A()) 
		: vector<Ch, A>(al)
	{
		if(pos>str.size()){
			__throw_out_of_range();
		}
		size_type rlen = str.size() - pos;
		if( rlen > n){
			rlen = n;
		}
		reserve(rlen);

		elements = rlen;
		Tr::copy(vector<Ch, A>::data, str.vector<Ch, A>::data + pos, elements);
	}

	basic_string(const Ch* s, size_type n, const A& al = A())
		: vector<Ch, A>(al)
	{
		if(n == npos){
			__throw_out_of_range();
		}
		if(s > 0){
			reserve(n);
			elements = n;
			Tr::copy(vector<Ch, A>::data, s, elements);
		}
	}

	basic_string(const Ch* s, const A& al = A());
	
	basic_string(size_type n, Ch c, const A& al = A())
		: vector<Ch, A>(n, c, al)
	{
	}

	template<class InputIterator> basic_string(InputIterator begin, InputIterator end, const A& a = A())
		:vector<Ch, A>(begin, end)
	{
		
	}
	~basic_string() { }

	basic_string& operator=(const basic_string& str){
		if(&str == this){	//Check if we are doing a=a 
			return *this;
		}
		clear();
		reserve(str.elements);
		Tr::copy( vector<Ch, A>::data, str.vector<Ch, A>::data, str.elements);
		elements = str.elements;
		return *this;
	}

	basic_string& operator=(const Ch* s){
		clear();
		if(s!=0){
			size_type len = Tr::length(s);
			reserve(len);
			Tr::copy( vector<Ch, A>::data, s, len);
			elements = len;
		}
		return *this;
	}

	basic_string& operator=(Ch c){
		clear();
		push_back(c);
		return *this;
	}

	inline size_type length() const { return size(); }

	void resize(size_type n){
		resize(n, Ch() );
	}

	basic_string& operator+=(const basic_string& str){
		return append(str);
	}

	basic_string& operator+=(const Ch * s){
		return append(s);;
	}

	basic_string& operator+=(Ch c){
		push_back(c);
		return *this;
	}

	basic_string& append(const basic_string& str){
		reserve(elements + str.elements);
		Tr::copy( vector<Ch, A>::data + elements, str.vector<Ch, A>::data, str.elements);
		elements += str.elements;

		return *this;
	}

	basic_string& append(const basic_string& str, size_type pos, size_type n){
		if(pos > str.size()){
			__throw_out_of_range();
		}

		size_type rlen = str.elements - pos;
		if(rlen > n){
			rlen = n;
		}
		if(elements > npos - rlen){
			__throw_length_error();
		}
		reserve(elements + rlen);
		elements += rlen;
		Tr::copy( data + elements, str.data, rlen);
		return *this;
	}
		
	basic_string& append(const Ch* s, size_type n){
		reserve(elements + n);
		Tr::copy( data + elements, s, n);
		elements+=n;
		return *this;
	}
	basic_string& append(const Ch* s){
		size_type strLen = Tr::length(s);
		reserve(elements + strLen);
		Tr::copy( vector<Ch, A>::data + elements, s, strLen);
		elements+=strLen;
		return *this;
	}

	basic_string& append(size_type n, Ch c){
		vector<Ch, A>::resize(elements+ n, c);
		return *this;
	}

	basic_string& assign(const basic_string& str){
		*this = str;
		return *this;
	}

	basic_string& assign(const basic_string& str, size_type pos, size_type n){
		if(pos > str.characters){
			__throw_out_of_range();
		}
		size_type rlen = str.characters - pos;
		if(rlen > n){
			rlen = n;
		}
		if(memorySize < rlen){
			//Not using reserve() because we don't need to keep the old data
			localAlloc.deallocate(data, data_size);
			data = localAlloc.allocate(data_size);
		}
		Tr::copy(data, str.data + pos, rlen);
		elements = rlen;
		return *this;
	}

	basic_string& assign(const Ch* s, size_type n){
		if( n > memorySize ){
			localAlloc.deallocate(data, data_size);
			stringPointer = localAlloc.allocate(data_size);
		}
		elements = n;
		Tr::copy(data, s, n);
		return *this;
	}

	basic_string& assign(const Ch* s){
		size_type len = Tr::length(s);
		return assign(s, len);
	}

	basic_string& assign(size_type n, Ch c){
		if(n > memorySize){
			localAlloc.deallocate(stringPointer, memorySize);
			stringPointer = localAlloc.allocate(memorySize);
		}
		Tr::assign( stringPointer, n ,c);
		characters = n;
		return *this;
	}

//	template<class InputIterator> basic_string& assign(InputIterator first, InputIterator last);

	basic_string& insert(size_type pos1, const basic_string& str){
		if(pos1 > elements){
			__throw_out_of_range();
		}
		if(elements > npos - str.elements){
			__throw_length_error();
		}
		reserve(str.elements + elements);

		Tr::move(data + pos1 + str.elements, data + pos1, str.elements);
		Tr::copy(data + pos1, str.data, str.elements);
		elements += str.elements;
		return *this;
	}

	basic_string& insert(size_type pos1, const basic_string& str, size_type pos2=0, size_type n=npos){
		if(pos1 > elements || pos2 > str.elements){
			__throw_out_of_range();
		}
		size_type rlen = str.elements - pos2;
		if( rlen > n){
			rlen = n;
		}
		if(elements > npos - rlen){
			__throw_length_error();
		}
		reserve(elements + rlen);
		Tr::move(data + pos1 + rlen, data + pos1, rlen);
		Tr::copy(data + pos1, str.data + pos2, rlen);
		characters+=rlen;
		return *this;
	}

	basic_string& insert(size_type pos, const Ch* s, size_type n){
		if(pos > elements){
			__throw_out_of_range();
		}
		if(elements > pos - n){
			__throw_length_error();
		}
		reserve(elements + n);
		Tr::move(data + pos + n, data + pos, n);
		Tr::copy(data + pos, s, n);
		elements+=n;
		return *this;
	}

	inline basic_string& insert(size_type pos, const Ch* s){
		size_type len = Tr::length(s);
		return insert(pos, s, len);
	}

	basic_string& insert(size_type pos, size_type n, Ch c){
		if(pos > elements){
			__throw_out_of_range();
		}
		if(elements > pos - n){
			__throw_length_error();
		}
		reserve(elements + n);
		Tr::move(data + pos + n, data + pos, n);
		Tr::assign(data + pos, n, c);
		elements+=n;
		return *this;
	}

//	iterator insert(iterator p, charT c = charT());
//	void insert(iterator p, size_type n, charT c);
//	template<class InputIterator> void insert(iterator p, InputIterator first, InputIterator last);

	basic_string& erase(size_type pos = 0, size_type n = npos){
		size_type xlen = elements - pos;
		if(xlen > n){
			xlen = n;
		}
		if( (elements - pos) > n){		//Deleteing past the end
			resize(pos);
		}else{				//Deleting from the middle
			Tr::move(data + pos, data + pos + xlen, xlen);
			resize(pos + xlen);
		}
		return *this;
	}

//	iterator erase(iterator position);
//	iterator erase(iterator first, iterator last);

//	basic_string& replace(size_type pos1, size_type n1, const basic_string& str);

	basic_string& replace(size_type pos1, size_type n1, const basic_string& str, size_type pos2=0, size_type n2=npos){
		if(pos1 > characters){
			__throw_out_of_range();
		}
		size_type xlen = elements - pos1;
		if(xlen >  n1){
			xlen = n1;
		}
		size_type rlen = str.elements - pos2;
		if(rlen > n2){
			rlen = n2;
		}
		if((elements - xlen) >= (npos - rlen)){
			__throw_length_error();
		}
		reserve(elements - xlen + rlen);

		//Final length = characters - xlen + rlen
		//Initial block is of size pos1
		//Block 2 is of size len

		Tr::move(data + pos1 + rlen, data + pos1 + xlen, characters - pos1 - xlen);
		Tr::copy(data + pos1, str.data + pos2, rlen);
		elements = elements - xlen + rlen;
		return *this;
	}

	basic_string& replace(size_type pos, size_type n1, const Ch* s, size_type n2){
		return replace(pos,n1,basic_string<Ch,Tr,A>(s,n2));
		
	}

	inline basic_string& replace(size_type pos, size_type n1, const Ch* s){
		return replace(pos,n1,basic_string<Ch,Tr,A>(s));
	}

	basic_string& replace(size_type pos, size_type n1, size_type n2, Ch c){
		return replace(pos,n1,basic_string<Ch, Tr, A>(n2,c));
	}
//	basic_string& replace(iterator i1, iterator i2, const basic_string& str);
//	basic_string& replace(iterator i1, iterator i2, const Ch* s, size_type n);
//	basic_string& replace(iterator i1, iterator i2, const Ch* s);
//	basic_string& replace(iterator i1, iterator i2, size_type n, Ch c);
/*	template<class InputIterator> basic_string& replace(iterator i1, iterator i2,
		InputIterator j1, InputIterator j2);*/

	size_type copy(Ch* s, size_type n, size_type pos = 0) const{
		if(pos > characters){
			__throw_out_of_range();
		}
		size_type rlen = characters - pos;
		if(rlen > n){
			rlen = n;
		}
		Tr::copy(s, &stringPointer[pos], rlen);
		return rlen;
	}

	void swap(basic_string<Ch,Tr,A>& s){
		//Data pointers
		Ch* tempPtr = s.stringPointer;
		s.stringPointer = stringPointer;
		stringPointer = tempPtr;

		//Amount of allocated memory
		size_type tempSize= s.memorySize;
		s.memorySize = memorySize;
		memorySize = tempSize;

		//Number of characters
		tempSize = s.characters;
		s.characters = characters;
		characters = tempSize;
	}

	const Ch* c_str() const{
		const_cast<basic_string<Ch,Tr,A> *>(this)->reserve(elements+1);
		vector<Ch, A>::data[elements] = 0;	//Add 0 at the end
		return vector<Ch, A>::data;
	}

	const Ch* data() const{
		return vector<Ch, A>::data;
	}
	allocator_type get_allocator() const{
		return localAlloc;
	};

/*	size_type find (const basic_string& str, size_type pos = 0) const;
	size_type find (const charT* s, size_type pos, size_type n) const;
	size_type find (const charT* s, size_type pos = 0) const;
	size_type find (charT c, size_type pos = 0) const;
	size_type rfind(const basic_string& str, size_type pos = npos) const;
	size_type rfind(const charT* s, size_type pos, size_type n) const;
	size_type rfind(const charT* s, size_type pos = npos) const;
	size_type rfind(charT c, size_type pos = npos) const;
	size_type find_first_of(const basic_string& str, size_type pos = 0) const;
	size_type find_first_of(const charT* s, size_type pos, size_type n) const;
	size_type find_first_of(const charT* s, size_type pos = 0) const;
	size_type find_first_of(charT c, size_type pos = 0) const;
	size_type find_last_of (const basic_string& str, size_type pos = npos) const;
	size_type find_last_of (const charT* s, size_type pos, size_type n) const;
	size_type find_last_of (const charT* s, size_type pos = npos) const;
	size_type find_last_of (charT c, size_type pos = npos) const;

	size_type find_first_not_of(const basic_string& str, size_type pos = 0) const;
	size_type find_first_not_of(const charT* s, size_type pos, size_type n) const;
	size_type find_first_not_of(const charT* s, size_type pos = 0) const;
	size_type find_first_not_of(charT c, size_type pos = 0) const;
	size_type find_last_not_of (const basic_string& str, size_type pos = npos) const;
	size_type find_last_not_of (const charT* s, size_type pos, size_type n) const;
	size_type find_last_not_of (const charT* s, size_type pos = npos) const;
	size_type find_last_not_of (charT c, size_type pos = npos) const;
*/

	basic_string substr(size_type pos = 0, size_type n = npos) const{
		if(pos > elements){
			__throw_out_of_range();
		}
		size_type rlen = elements - pos;
		if(rlen > n){
			rlen = n;
		}
		return basic_string<Ch,Tr,A>(data + pos,rlen);
	}

	int compare(const basic_string& str) const{
		size_type rlen = elements;
		if(rlen >  str.elements){
			rlen = str.elements;
		}
		int retval = Tr::compare(vector<Ch, A>::data, str.vector<Ch, A>::data, rlen);
		if(retval == 0){
			if(elements < str.elements){
				retval = -1;
			}
			if(elements > str.elements){
				retval = 1;
			}
		}
		return retval;
	}

	int compare(size_type pos1, size_type n1, const basic_string& str) const{
		size_type rlen = elements - pos1;
		if(rlen > n1){
			rlen = n1;
		}
		if(rlen > str.elements){
			rlen = str.elements;
		}
		int retval = Tr::compare(data + pos1, str.data, rlen);
		if(retval == 0){
			if(elements - pos1 < str.elements){
				retval = -1;
			}
			if(elements - pos1 > str.elements){
				retval = 1;
			}
		}
		return retaval;
	}

	int compare(size_type pos1, size_type n1, const basic_string& str,
		size_type pos2=0, size_type n2=npos) const{
		size_type len1 = elements - pos1;
		if(len1 > n1){
			len1 = n1;
		}
		size_type len2 = elements - pos2;
		if(len2 > n2){
			len2 = n2;
		}
		size_type rlen = len1;
		if(len > len2){
			rlen = len2;
		}
		int retval = Tr::compare(vector<Ch, A>::data + pos1, str.vector<Ch, A>::data + pos2, rlen);
		if(retval == 0){
			if(len1 < len2){
				retval = -1;
			}
			if(len1 > len2){
				retval = 1;
			}
		}
		return retval;
	}

	int compare(const Ch* s) const{
		size_type slen = Tr::length(s);
		size_type rlen = slen;
		if(rlen > elements){
			rlen=elements;
		}
		int retval = Tr::compare(vector<Ch, A>::data, s, rlen);
		if(retval==0){
			if(elements < slen){
				retval = -1;
			}
			if(elements > slen){
				retval = 1;
			}
		}
		return retval;
	}

	int compare(size_type pos1, size_type n1, const Ch* s, size_type n2 = npos) const{
		size_type len1 = elements - pos1;
		if(len1 > n1){
			len1 = n1;
		}
		size_type slen = Tr::length(s);
		size_type len2 = slen;
		if(len2 > n2){
			len2 = n2;
		}
		size_type rlen = len1;
		if(rlen > len2){
			rlen = len2;
		}
		int retval  = Tr::compare(vector<Ch, A>::data + pos1, s, rlen);
		if(retval == 0){
			if(len1 < len2){
				retval = -1;
			}
			if(len1 > len2){
				retval = 1;
			}
		}
		return retval;
	}

};


//Functions

template<class Ch,class Tr,class A> basic_string<Ch,Tr,A>::basic_string(const Ch* s, const A& al)
	: vector<Ch, A>(al)
{
	__string_helper_functions<Ch, Tr, A>::constructor(*this, s);
}

#ifdef __UCLIBCXX_EXPAND_STRING_CHAR__
	template<> basic_string<char,char_traits<char>, allocator<char> >::basic_string(const char* s, const allocator<char>& al);
#endif




//typedef basic_string<char> string;

template<class charT, class traits, class Allocator> basic_string<charT,traits,Allocator> 
	operator+(const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	basic_string<charT,traits,Allocator> temp(lhs);
	temp.append(rhs);
	return temp;
}

template<class charT, class traits, class Allocator> basic_string<charT,traits,Allocator>
	operator+(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	basic_string<charT,traits,Allocator> temp(lhs);
	temp.append(rhs);
	return temp;
}


template<class charT, class traits, class Allocator> basic_string<charT,traits,Allocator>
	operator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator> basic_string<charT,traits,Allocator>
	operator+(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	basic_string<charT,traits,Allocator> temp(lhs);
	temp.append(rhs);
	return temp;
}

template<class charT, class traits, class Allocator> basic_string<charT,traits,Allocator>
	operator+(const basic_string<charT,traits,Allocator>& lhs, charT rhs);

template<class charT, class traits, class Allocator> bool 
	operator==(const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	if(lhs.compare(rhs) == 0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator==(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	if(rhs.compare(lhs) == 0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	if(lhs.compare(rhs)==0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator!=(const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	if(lhs.compare(rhs) !=0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator!=(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	basic_string<charT,traits,Allocator> temp(lhs);
	return (temp != rhs);
}

template<class charT, class traits, class Allocator> bool 
	operator!=(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	basic_string<charT,traits,Allocator> temp(rhs);
	return (lhs != rhs);
}

template<class charT, class traits, class Allocator> bool 
	operator< (const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	if(lhs.compare(rhs) < 0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator< (const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	basic_string<charT,traits,Allocator> temp(rhs);
	if(lhs.compare(rhs) < 0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator< (const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	basic_string<charT,traits,Allocator> temp(lhs);
	if(temp.compare(rhs) < 0){
		return true;
	}
	return false;
}


template<class charT, class traits, class Allocator> bool 
	operator> (const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	if(lhs.compare(rhs) > 0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator> (const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	basic_string<charT,traits,Allocator> temp(rhs);
	if(lhs.compare(rhs) > 0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator> (const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	basic_string<charT,traits,Allocator> temp(lhs);
	if(temp.compare(rhs) > 0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator<=(const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	if(lhs.compare(rhs) <=0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator<=(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	basic_string<charT,traits,Allocator> temp(rhs);
	if(lhs.compare(temp <=0)){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator<=(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	basic_string<charT,traits,Allocator> temp(lhs);
	if(temp.compare(rhs) <0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator>=(const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	if(lhs.compare(rhs) >=0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator>=(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	basic_string<charT,traits,Allocator> temp(rhs);
	if(lhs.compare(temp)>=0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> bool 
	operator>=(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	basic_string<charT,traits,Allocator> temp(lhs);
	if(temp.compare(rhs)>=0){
		return true;
	}
	return false;
}

template<class charT, class traits, class Allocator> void 
	swap(basic_string<charT,traits,Allocator>& lhs, basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator> basic_ostream<charT, traits>&
	operator<<(basic_ostream<charT, traits>& os, const basic_string<charT,traits,Allocator>& str)
{
	return os.write(str.data(), str.length());
}

#ifdef __UCLIBCXX_EXPAND_OSTREAM_CHAR__
#ifdef __UCLIBCXX_EXPAND_STRING_CHAR__
template<> basic_ostream<char, char_traits<char> >&
	operator<<(basic_ostream<char, char_traits<char> >& os, 
	const basic_string<char,char_traits<char>, std::allocator<char> >& str);
#endif
#endif

template<class charT, class traits, class Allocator> basic_istream<charT,traits>&
	operator>>(basic_istream<charT,traits>& is, basic_string<charT,traits,Allocator>& str)
{
	return __string_helper_functions<charT, traits, Allocator>::op_right_right(is, str);
}

template<class charT, class traits, class Allocator> basic_istream<charT,traits>&
	getline(basic_istream<charT,traits>& is, basic_string<charT,traits,Allocator>& str, charT delim)
{
	typename basic_istream<charT,traits>::sentry s;
	streamsize i = 0;
	typename basic_istream<charT,traits>::int_type c_i;
	charT c;
	unsigned int n = str.max_size();
	for(i=0;i<n;++i){
		c_i=is.get();
		if(c_i == traits::eof() ){
			return is;
		}
		c = traits::to_char_type(c_i);
		if(c == delim){
			return is;
		}
		str.append(c);
	}
	return is;	
}

template<class charT, class traits, class Allocator> basic_istream<charT,traits>&
	getline(basic_istream<charT,traits>& is, basic_string<charT,traits,Allocator>& str)
{
	return getline(is, str, '\n');
}

#ifdef __UCLIBCXX_EXPAND_ISTREAM_CHAR__
#ifdef __UCLIBCXX_EXPAND_STRING_CHAR__
template<> basic_istream<char, char_traits<char> >& operator>>(
	basic_istream<char,char_traits<char> >& is,
	basic_string<char, char_traits<char>,
	allocator<char> >& str
);
#endif
#endif


typedef basic_string<char> string;
typedef basic_string<wchar_t> wstring;


};

#endif

