/*	Copyright (C) 2004 Garrett A. Kajmowicz
	This file is part of the uClibc++ Library.
	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License as published by the Free Software Foundation; either
	version 2.1 of the License, or (at your option) any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with this library; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#ifndef __STD_HEADER_FUNCTIONAL
#define __STD_HEADER_FUNCTIONAL 1

namespace std{

	template <class Arg, class Result> struct unary_function;
	template <class Arg1, class Arg2, class Result> struct binary_function;

	template <class T> struct plus;
	template <class T> struct minus;
	template <class T> struct multiplies;
	template <class T> struct divides;
	template <class T> struct modulus;
	template <class T> struct negate;

	template <class T> struct equal_to;
	template <class T> struct not_equal_to;
	template <class T> struct greater;
	template <class T> struct less;
	template <class T> struct greater_equal;
	template <class T> struct less_equal;

	template <class T> struct logical_and;
	template <class T> struct logical_or;
	template <class T> struct logical_not;

	template <class Predicate> struct unary_negate;
	template <class Predicate> unary_negate<Predicate>  not1(const Predicate&);
	template <class Predicate> struct binary_negate;
	template <class Predicate> binary_negate<Predicate> not2(const Predicate&);


	template <class Operation>  class binder1st;
	template <class Operation, class T> binder1st<Operation> bind1st(const Operation&, const T&);
	template <class Operation> class binder2nd;
	template <class Operation, class T> binder2nd<Operation> bind2nd(const Operation&, const T&);

	template <class Arg, class Result> class pointer_to_unary_function;
	template <class Arg, class Result> pointer_to_unary_function<Arg,Result> ptr_fun(Result (*)(Arg));
	template <class Arg1, class Arg2, class Result> class pointer_to_binary_function;
	template <class Arg1, class Arg2, class Result> 
		pointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*)(Arg1,Arg2));

	template<class S, class T> class mem_fun_t;
	template<class S, class T, class A> class mem_fun1_t;
	template<class S, class T> mem_fun_t<S,T> mem_fun(S (T::*f)());
	template<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun1(S (T::*f)(A));
	template<class S, class T> class mem_fun_ref_t;
	template<class S, class T, class A> class mem_fun1_ref_t;
	template<class S, class T> mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)());
	template<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun1_ref(S (T::*f)(A));





	//Implementation

	template <class Arg, class Result> struct unary_function{
		typedef Arg argument_type;
		typedef Result result_type;
	};


	template <class Arg1, class Arg2, class Result> struct binary_function{
		typedef Arg1   first_argument_type;
		typedef Arg2   second_argument_type;
		typedef Result result_type;
	};

	template <class T> struct plus : binary_function<T,T,T>{
		T operator()(const T& x, const T& y) const{
			return x + y;
		}
	};

	template <class T> struct minus : binary_function<T,T,T>{
		T operator()(const T& x, const T& y) const{
			return x - y;
		}
	};

	template <class T> struct multiplies : binary_function<T,T,T>{
		T operator()(const T& x, const T& y) const{
			return x * y;
		}
	};

	template <class T> struct divides : binary_function<T,T,T>{
		T operator()(const T& x, const T& y) const{
			return x / y;
		}
	};

	template <class T> struct modulus : binary_function<T,T,T>{
		T operator()(const T& x, const T& y) const{
			return x % y;
		}
	};

	template <class T> struct negate : unary_function<T,T>{
		T operator()(const T& x) const{
			return -x;
		}
	};

	template <class T> struct equal_to : binary_function<T,T,bool>{
		bool operator()(const T& x, const T& y) const{
			return (x == y);
		}
	};

	template <class T> struct not_equal_to : binary_function<T,T,bool>{
		bool operator()(const T& x, const T& y) const{
			return (x != y);
		}
	};

	template <class T> struct greater : binary_function<T,T,bool>{
		bool operator()(const T& x, const T& y) const{
			return (x > y);
		}
	};

	template <class T> struct less : binary_function<T,T,bool>{
		bool operator()(const T& x, const T& y) const{
			return (x < y);
		}
	};

	template <class T> struct greater_equal : binary_function<T,T,bool>{
		bool operator()(const T& x, const T& y) const{
			return (x >= y);
		}
	};

	template <class T> struct less_equal : binary_function<T,T,bool>{
		bool operator()(const T& x, const T& y) const{
			return (x <= y);
		}
	};




};

#endif



