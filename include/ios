/*	Copyright (C) 2004 Garrett A. Kajmowicz

	This file is part of the uClibc++ Library.

	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License as published by the Free Software Foundation; either
	version 2.1 of the License, or (at your option) any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with this library; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include <basic_definitions>
#include <exception>
#include <locale>
#include <memory>
#include <string>
#include <iosfwd>
#include <cstdio>

#ifndef HEADER_STD_IOS
#define HEADER_STD_IOS 1

namespace std{
//	typedef OFF_T streamoff;
	template <class stateT> class fpos;

	class ios_base;

	ios_base& boolalpha  (ios_base& str);
	ios_base& noboolalpha(ios_base& str);
	ios_base& showbase   (ios_base& str);
	ios_base& noshowbase (ios_base& str);
	ios_base& showpoint  (ios_base& str);
	ios_base& noshowpoint(ios_base& str);
	ios_base& showpos    (ios_base& str);
	ios_base& noshowpos  (ios_base& str);
	ios_base& skipws     (ios_base& str);
	ios_base& noskipws   (ios_base& str);
	ios_base& uppercase  (ios_base& str);
	ios_base& nouppercase(ios_base& str);

	ios_base& internal   (ios_base& str);
	ios_base& left       (ios_base& str);
	ios_base& right      (ios_base& str);

	ios_base& dec        (ios_base& str);
	ios_base& hex        (ios_base& str);
	ios_base& oct        (ios_base& str);

	ios_base& fixed      (ios_base& str);
	ios_base& scientific (ios_base& str);

	class ios_base {
	public:
		class failure;
#ifdef __UCLIBCXX_SUPPORT_CDIR__
		class Init{
		public:
			Init();
			~Init();
		private:
			static int init_cnt;
		};
#endif

		public:

		typedef unsigned short int fmtflags;

		static const fmtflags skipws 		= 0x0001;

		static const fmtflags left		= 0x0002;
		static const fmtflags right		= 0x0004;
		static const fmtflags internal		= 0x0008;

		static const fmtflags boolalpha		= 0x0010;

		static const fmtflags dec	 	= 0x0020;
		static const fmtflags oct 		= 0x0040;
		static const fmtflags hex 		= 0x0080;

		static const fmtflags scientific	= 0x0100;
		static const fmtflags fixed 		= 0x0200;

		static const fmtflags showbase 		= 0x0400;
		static const fmtflags showpoint		= 0x0800;
		static const fmtflags showpos		= 0x1000;
		static const fmtflags uppercase		= 0x2000;

		static const fmtflags adjustfield	= left | right | internal;
		static const fmtflags basefield		= dec | oct | hex;
		static const fmtflags floatfield	= fixed | scientific;

		static const fmtflags unitbuf		= 0x4000;

		typedef unsigned char iostate;
		static const iostate goodbit		= 0x00;
		static const iostate badbit		= 0x01;
		static const iostate eofbit		= 0x02;
		static const iostate failbit 		= 0x04;

		typedef unsigned char openmode;
		static const openmode app		= 0x01;
		static const openmode ate		= 0x02;
		static const openmode binary		= 0x04;
		static const openmode in		= 0x08;
		static const openmode out		= 0x10;
		static const openmode trunc		= 0x20;

		typedef unsigned char seekdir;
		static const seekdir beg		= 0x01;
		static const seekdir cur		= 0x02;
		static const seekdir end		= 0x04;

		fmtflags flags() const{
			return mformat;
		}
		fmtflags flags(fmtflags fmtfl);

		fmtflags setf(fmtflags fmtfl);
		fmtflags setf(fmtflags fmtfl, fmtflags mask ){
//			fmtflags temp = mformat;
//			mformat = (mformat& (~mask)) | (fmtfl & mask);
//			return temp;
			return flags( (flags()& ~mask) | (fmtfl & mask));
		}

		void unsetf(fmtflags mask){
			mformat&= ~mask;
		}

		streamsize precision() const{
			return mprecision;
		}

		streamsize precision(streamsize prec){
			streamsize temp = mprecision;
			mprecision = prec;
			return temp;
		}

		streamsize width() const{
			return mwidth;
		}

		streamsize width(streamsize wide){
			streamsize temp = mwidth;
			mwidth = wide;
			return temp;
		}

		locale imbue(const locale& loc){
			locale retval = mLocale;
			mLocale = loc;
			return retval;
		}

		locale getloc() const{
			return mLocale;
		}

//		FIXME - These need to be implemented
//		static int xalloc();
//		long&  iword(int index);
//		void*& pword(int index);

		~ios_base() { }

		enum event { erase_event, imbue_event, copyfmt_event };

		typedef void (*event_callback)(event, ios_base&, int index);
//		void register_callback(event_call_back fn, int index);

		//We are going to wrap stdio so we don't need implementation of the following:
		inline static bool sync_with_stdio(bool sync = true) { return true; }

	protected:
		ios_base() : mLocale(), mformat(dec | showbase | unitbuf ), mstate(goodbit), 
			mmode(), mdir(), mprecision(6), mwidth(0)
#ifdef __UCLIBCXX_SUPPORT_CDIR__
			,mInit()
#endif
		{

		}
		locale mLocale;
		fmtflags mformat;
		iostate mstate;
		openmode mmode;
		seekdir mdir;
		streamsize mprecision;
		streamsize mwidth;
#ifdef __UCLIBCXX_SUPPORT_CDIR__
		Init mInit;
#endif
	};

	template <class charT, class traits > class basic_ios : public ios_base {
	public:
	// Types:
		typedef charT char_type;
		typedef typename traits::int_type int_type;
		typedef typename traits::pos_type pos_type;
		typedef typename traits::off_type off_type;
		typedef traits traits_type;

		operator void*() const;
		bool operator!() const;
		iostate rdstate() const{
			return mstate;
		}
		void clear(iostate state = goodbit){
			if(rdbuf()!=0){
				minternalState = state;
			}else{
				minternalState = state|ios_base::badbit;
			}
		}
		void setstate(iostate state) {
			clear(rdstate()  | state);
		}

		bool good() const{
			return (rdstate() == 0);
		}
		bool eof()  const{
			if(rdstate() & eofbit){
				return true;
			}
			return false;
		}
		bool fail() const;
		bool bad()  const;

		iostate exceptions() const;
		void exceptions(iostate except);

		explicit basic_ios(basic_streambuf<charT,traits>* sb) : mtied(0), mstreambuf(0), minternalState(goodbit){
			init(sb);
		}
		virtual ~basic_ios(){

		}

		basic_ostream<charT,traits>* tie() const{
			return mtied;
		}
		basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr){
			basic_ostream<charT,traits>* retval= mtied;
			mtied = tiestr;
			return retval;			
		}
		basic_streambuf<charT,traits>* rdbuf() const{
			return mstreambuf;
		}
		basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb){
			basic_streambuf<charT,traits>* retval = mstreambuf;
			mstreambuf = sb;
			return retval;
		}
		basic_ios& copyfmt(const basic_ios& rhs);
		char_type fill() const{
			return widen(' ');
		}
		char_type fill(char_type ch);


		locale imbue(const locale& loc);
		char narrow(char_type c, char dfault) const;
		char_type widen(char c) const{
//			return use_facet< ctype<char_type> >(getloc()).widen(c);
			return c;
		}
	protected:
		basic_ostream<charT,traits>* mtied;
		basic_streambuf<charT,traits>* mstreambuf;
		iostate minternalState;
		basic_ios() : mtied(0), mstreambuf(0), minternalState(goodbit){	}
		basic_ios(const basic_ios<charT,traits> &){ }
		basic_ios<charT,traits> & operator=(const basic_ios<charT,traits> &){ return *this; }
		void init(basic_streambuf<charT,traits>* sb){
			mstreambuf = sb;
			minternalState = goodbit;
		}
	};


	template <class stateT> class fpos{
	public:
		fpos(stateT s){
			st = s;
		}
		stateT state() const{
			return st;
		}
		void state(stateT s){
			st = s;
		}
	private:
		stateT st;
	};




};

#endif

