/*	Copyright (C) 2004 Garrett A. Kajmowicz

	This file is part of the uClibc++ Library.

	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License as published by the Free Software Foundation; either
	version 2.1 of the License, or (at your option) any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with this library; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include <new>
#include <cstddef>

#ifndef HEADER_STD_MEMORY
#define HEADER_STD_MEMORY 1

namespace std{

template <class T> class allocator;
	// Specialize for void:

template <> class allocator<void> {
public:
	typedef void*       pointer;
	typedef const void* const_pointer;
	typedef void  value_type;
	template <class U> struct rebind { typedef allocator<U> other; };
};

template <class T> class allocator{
public:
	typedef T value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	
	typedef T* pointer;
	typedef const T* const_pointer;

	typedef T& reference;
	typedef const T& const_reference;

	pointer address(reference r) const { return &r; }
	const_pointer address(const_reference r) const { return &r; }
	
	allocator() throw(){}
	template <class U> allocator(const allocator<U>& ) throw();
	~allocator() throw(){}

	//Space for n Ts
//	pointer allocate(size_type n, typename allocator<void>::const_pointer hint=0){
	pointer allocate(size_type n, typename allocator<void>::const_pointer = 0){
		return new T[n];
	}
	void deallocate(pointer p, size_type){
		delete [] p;
	}

	//Use placement new to engage the constructor
	void construct(pointer p, const T& val) { new(p)T(val); }
	void destroy(pointer p){p->~T(); }	//Call destructor

	size_type max_size() const throw();
	template<class U> struct rebind { typedef allocator<U> other; };

};

}

#endif

