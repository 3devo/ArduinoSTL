#include <new>
#include <cstddef>

#ifndef HEADER_STD_MEMORY
#define HEADER_STD_MEMORY 1

namespace std{

template <class T> class allocator;
	// Specialize for void:

template <> class allocator<void> {
public:
	typedef void*       pointer;
	typedef const void* const_pointer;
	typedef void  value_type;
	template <class U> struct rebind { typedef allocator<U> other; };
};

template <class T> class allocator{
public:
	typedef T value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	
	typedef T* pointer;
	typedef const T* const_pointer;

	typedef T& reference;
	typedef const T& const_reference;

	pointer address(reference r) const { return &r; }
	const_pointer address(const_reference r) const { return &r; }
	
	allocator() throw(){}
	template <class U> allocator(const allocator<U>& ) throw();
	~allocator() throw(){}

	//Space for n Ts
//	pointer allocate(size_type n, typename allocator<void>::const_pointer hint=0){
	pointer allocate(size_type n, typename allocator<void>::const_pointer = 0){
		return new T[n];
	}
	void deallocate(pointer p, size_type){
		delete [] p;
	}

	//Use placement new to engage the constructor
	void construct(pointer p, const T& val) { new(p)T(val); }
	void destroy(pointer p){p->~T(); }	//Call destructor

	size_type max_size() const throw();
	template<class U> struct rebind { typedef allocator<U> other; };

};

};

#endif

