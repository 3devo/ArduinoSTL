/*	Copyright (C) 2004 Garrett A. Kajmowicz

	This file is part of the uClibc++ Library.

	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License as published by the Free Software Foundation; either
	version 2.1 of the License, or (at your option) any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with this library; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*/

#include <basic_definitions>
#include <memory>
#include <iterator>
#include <vector_helpers>


#ifndef __STD_HEADER_VECTOR
#define __STD_HEADER_VECTOR

namespace std{

	template <class T, class Allocator = allocator<T> > class vector;
	template <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
	template <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);
	template <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
	template <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);
	template <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
	template <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
	template <class T, class Allocator> void swap(vector<T,Allocator>& x, vector<T,Allocator>& y);

	template <class Allocator> bool operator==(const vector<bool,Allocator>& x, const vector<bool,Allocator>& y);
	template <class Allocator> bool operator< (const vector<bool,Allocator>& x, const vector<bool,Allocator>& y);
	template <class Allocator> bool operator!=(const vector<bool,Allocator>& x, const vector<bool,Allocator>& y);
	template <class Allocator> bool operator> (const vector<bool,Allocator>& x, const vector<bool,Allocator>& y);
	template <class Allocator> bool operator>=(const vector<bool,Allocator>& x, const vector<bool,Allocator>& y);
	template <class Allocator> bool operator<=(const vector<bool,Allocator>& x, const vector<bool,Allocator>& y);
	template <class Allocator> void swap(vector<bool,Allocator>& x, vector<bool,Allocator>& y);


	template <class T, class Allocator> class vector {
		friend class __vector_helper_functions<T, Allocator>;
	public:

		typedef typename Allocator::reference reference;
		typedef typename Allocator::const_reference const_reference;
		typedef typename Allocator::size_type size_type;
		typedef typename Allocator::difference_type difference_type;
		typedef typename Allocator::pointer pointer;
		typedef typename Allocator::const_pointer const_pointer;

		typedef T* iterator;
		typedef const T* const_iterator;
		typedef T value_type;
		typedef Allocator allocator_type;
		typedef std::reverse_iterator<iterator> reverse_iterator;
		typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

		explicit vector(const Allocator& al= Allocator()): data(0), data_size(__DEFAULT_ALLOC_UNITS), elements(0), a(al){
			data = a.allocate(data_size);
		}

		explicit vector(size_type n, const T& value = T(), const Allocator& al= Allocator()) : 
			data(0), data_size(0), elements(0), a(al)
		{
			elements = n;
			data_size = elements + __DEFAULT_ALLOC_UNITS;
			data = a.allocate(data_size);

			for(size_type i = 0; i < elements; i++){
				data[i] = value;
			}
		}

		template <class InputIterator> vector(InputIterator first, InputIterator last, const Allocator& al = Allocator()):
			data(0), data_size(__DEFAULT_ALLOC_UNITS), elements(a), a(al)
		{
			data = a.allocate(data_size);
			assign(first, last);
		}

		vector(const vector<T,Allocator>& x){
			a = x.a;

			elements  = x.elements;
			data_size = elements + __DEFAULT_ALLOC_UNITS;
			data = a.allocate(data_size);

			for(size_type i = 0; i < elements; i++){
				data[i] = x.data[i];
			}	
		}

		~vector(){
			a.deallocate(data, data_size);
			data = 0;
			elements = 0;
			data_size=0;
		}

		vector<T,Allocator>& operator=(const vector<T,Allocator>& x){
			if(&x == this){
				return this;
			}

			delete [] data;
			data = 0;

			elements = x.elements;
			data_size = elements + __DEFAULT_ALLOC_UNITS;
			data = a.allocate(data_size);

			for(size_type i = 0; i < elements; i++){
				data[i] = x.data[i];
			}

			return *this;
		}

		template <class InputIterator> void assign(InputIterator first, InputIterator last){
			clear();
			insert(begin(), first, last);
		}

		template <class Size, class U> void assign(Size n, const U& u = U()){
			clear();
			resize(s, u);
		}

		inline allocator_type get_allocator() const{
			return a;
		}

		inline iterator begin(){
			return data;
		}

		inline const_iterator begin() const{
			return data;
		}

		inline iterator end(){
			return (data + elements);
		}

		inline const_iterator end() const{
			return (data + elements);
		}

		inline reverse_iterator rbegin(){
			return reverse_iterator(end());
		}

		inline const_reverse_iterator rbegin() const{
			return const_reverse_iterator(end());
		}

		inline reverse_iterator rend(){
			return reverse_iterator(begin());
		}

		inline const_reverse_iterator rend() const{
			return const_reverse_iterator(begin());
		}

		inline size_type size() const{
			return elements;
		}

		size_type max_size() const{
			return ((size_type)(-1)) / sizeof(T);
		}

		void resize(size_type sz, T c = T());

		inline size_type capacity() const{
			return data_size;
		}

		inline bool empty() const{
			return (size() == 0);
		}

		void reserve(size_type n);

		inline reference operator[](size_type n){
			return data[n];
		}

		inline const_reference operator[](size_type n) const{
			return data[n];
		}

		const_reference at(size_type n) const{
			if(n >= elements){
				__throw_out_of_range("Invalid subscript");
			}else{
				return data[n];
			}
		}

		reference at(size_type n){
			if(n >= elements){
				__throw_out_of_range("Invalid subscript");
			}else{
				return data[n];
			}
		}

		inline reference front(){
			return data[0];
		}

		inline const_reference front() const{
			return data[0];
		}

		inline reference back(){
			return data[ size() - 1];
		}

		inline const_reference back() const{
			return data[ size() - 1 ];
		}

		inline void push_back(const T& x){
			resize( size() + 1, x);
		}

		inline void pop_back(){
			resize(size() - 1);
		}

		iterator insert(iterator position, const T& x = T()){
			size_type index = position - data;
			resize(size() + 1);
			for(size_type i = elements - 1; i > index; --i){
				data[i] = data[i-1];
			}
			data[index] = x;
			return (data + index);
		}

		//FIXME - problems with x = typeof(int).  Works fine with uint
		void insert(iterator position, size_type n, const T& x ){
			size_type index = position - data;
			resize(size() + n);

			for(size_type i = elements -1; (i > (index+n-1)); --i){
				data[i] = data[i-n];
			}
			for(size_type i = 0; i < n; i++){
				data[i + index]  = x;
			}
		}

		template <class InputIterator> void insert(iterator position, InputIterator first, InputIterator last){
			T temp;
			while(first !=last){
				temp = *first;
				position = insert(position, temp);
				++position;
				++first;
			}
		}

		iterator erase(iterator position){
			size_type index = position - data;
			for(size_type i = index; i < (elements - 1); ++i){
				data[i] = data[i+1];
			}
			resize(size() - 1);
			return (data + index);
		}

		iterator erase(iterator first, iterator last){
			size_type index = first - data;
			size_type width = last - first;
			for(size_type i = index; i < (elements - width) ;++i){
				data[i] = data[i+width];
			}
			resize(size() - width);
			return (data + index);
		}


		void swap(vector<T,Allocator>& v){
			if(this == &v){		//Avoid dv.swap(v)
				return;
			}
			T* ptr;
			size_type temp;

			//Swap pointers first
			ptr = data;
			data = v.data;
			v.data  = ptr;

			//Swap element counts
			temp = elememts;
			elements = v.elements;
			v.elements = temp;

			//Swap data size
			temp = data_size;
			data_size = v.data_size;
			v.data_size = temp;
		}

		void clear(){
			elements = 0;
		}

	protected:
		T* data;
		size_type data_size;
		size_type elements;
		Allocator a;
	};



	//Here go template instantiations

	template<class T, class Allocator> void vector<T, Allocator>::reserve(size_type n){
		__vector_helper_functions<T, Allocator>::reserve(*this, n);
	}

	template<class T, class Allocator> void vector<T, Allocator>::resize(size_type sz, T c){
		__vector_helper_functions<T, Allocator>::resize(*this, sz, c);
	}


#ifdef __EXPAND_VECTOR_FOR_BASIC_TYPES
	template<> void vector<char, allocator<char> >::reserve(size_type n);
	template<> void vector<unsigned char, allocator<unsigned char> >::reserve(size_type n);
	template<> void vector<short int, allocator<short int> >::reserve(size_type n);
	template<> void vector<unsigned short int, allocator<unsigned short int> >::reserve(size_type n);
	template<> void vector<int, allocator<int> >::reserve(size_type n);
	template<> void vector<unsigned int, allocator<unsigned int> >::reserve(size_type n);
	template<> void vector<long int, allocator<long int> >::reserve(size_type n);
	template<> void vector<unsigned long int, allocator<unsigned long int> >::reserve(size_type n);
	template<> void vector<float, allocator<float> >::reserve(size_type n);
	template<> void vector<double, allocator<double> >::reserve(size_type n);
	template<> void vector<bool, allocator<bool> >::reserve(size_type n);

	template<> void vector<char, allocator<char> >::resize(size_type sz, char c);
	template<> void vector<unsigned char, allocator<unsigned char> >::resize(size_type sz, unsigned char c);
	template<> void vector<short int, allocator<short int> >::resize(size_type sz, short c);
	template<> void vector<unsigned short int, allocator<unsigned short int> >::resize(size_type sz, unsigned short int c);
	template<> void vector<int, allocator<int> >::resize(size_type sz, int c);
	template<> void vector<unsigned int, allocator<unsigned int> >::resize(size_type sz, unsigned int c);
	template<> void vector<long int, allocator<long int> >::resize(size_type sz, long int c);
	template<> void vector<unsigned long int, allocator<unsigned long int> >::resize(size_type sz, unsigned long int c);
	template<> void vector<float, allocator<float> >::resize(size_type sz, float c);
	template<> void vector<double, allocator<double> >::resize(size_type sz, double c);
	template<> void vector<bool, allocator<bool> >::resize(size_type sz, bool c);

#endif



	template <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y){
		if(x.elemebnt !=y.elements){

		}
	}
	template <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);
	template <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
	template <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);
	template <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
	template <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);
	template <class T, class Allocator> void swap(vector<T,Allocator>& x, vector<T,Allocator>& y);


	

};


#endif

